#include "AutoEncoder.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AutoEncoder::AutoEncoder(Arguments* A, DatasetParam* D)
{
	Arg = A;
	DP = D;

	/*Set the number of CPU cores available*/
	Cores = thread::hardware_concurrency();

	/*Set the number of dictionaries based on the number of CPU cores with one extra dictionary for non-threaded tasks*/
	FC_Cache = new Mat_Dictionary[Cores + 1];
	FC_Grades = new Mat_Dictionary[Cores + 1];

	/*Set the names of these dictionaries*/
	FC_Parameters.setName("FC_Parameters");

	for (int i = 0; i < Cores + 1; i++)
	{
		FC_Cache[i].setName(CharGen("FC_Cache", i));
		FC_Grades[i].setName(CharGen("FC_Grades", i));
	}

	/*Initialize the required network*/
	switch (Arg->NetType)
	{
	case FC:
		init_FC();
		break;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AutoEncoder::train()
{
	switch (Arg->NetType)
	{
	case FC:
		train_FC();
		break;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AutoEncoder::test(Mode devOrtest)
{
	/*ARGUMENT LIST*/
	U_IntMatrix* Y_dev = Arg->Y_dev;
	U_IntMatrix* Y_test = Arg->Y_test;
	/*END OF ARGUMENT LIST*/

	Matrix* Y_hat = nullptr;
	switch (Arg->NetType)
	{
	case FC:
		test_FC(devOrtest);
		break;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AutoEncoder::StoreParameters()
{
	if (Arg->SaveParameters)
	{
		FC_Parameters.Write(DP->ParametersPath);
		FC_ADAM.Write(DP->ParametersPath);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AutoEncoder::RetrieveParameters()
{
	if (Arg->RetrieveParameters)
	{
		FC_Parameters.Read(DP->ParametersPath);
		FC_ADAM.Read(DP->ParametersPath);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AutoEncoder::StoreActivations()
{
	if (Arg->SaveActivation)
	{
		cout << ">> Storing Bottleneck Activations .." << endl;
		for (DP->curFile = 0; DP->curFile < DP->numFiles; DP->curFile++)
		{
			if (Arg->Stack)
			{

				Arg->A = new Matrix(DP->ImageSize, DP->Train_Examples);
				Arg->A->Read(DP->A_dir[DP->curFile]);
				Arg->ActivationsPath = DP->ActivationsPath;
				Arg->ActivationsPath.append(CharGen("_", DP->curFile + 1));
				Matrix* All_X = (DP->Noisy_Data) ? Arg->A_Noisy : Arg->A;
				FC_Cache[Cores].put("A0", All_X);
				Bottleneck_FeedForward(Cores);
				FC_Cache[Cores].DeleteThenClearTEST();
				delete Arg->A;
			}
			else
			{
				Get_TrainSet(*Arg, *DP);
				Arg->ActivationsPath = DP->ActivationsPath;
				Arg->ActivationsPath.append(CharGen("_", DP->curFile + 1));
				Matrix* All_X = ConvertMat_U(Arg->X, UC_F, YES);
				FC_Cache[Cores].put("A0", All_X);
				Bottleneck_FeedForward(Cores);
				//FC_Cache[Cores]["A1"]->SubMat(0,0,199,10)->print();
				//cluster(Arg->X_test, FC_Cache[Cores]["A1"], 0.97);
				FC_Cache[Cores].DeleteThenClear();
			}
		}
		Arg->SaveActivation = false;
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AutoEncoder::TestParameters()
{
	if (Arg->TestParameters)
		test(TEST);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AutoEncoder::Print()
{
	FC_Parameters.print();
	FC_ADAM.print();
}
